variables:
  GIT_DEPTH: 0  # 获取完整的 git 历史，避免浅克隆导致推送失败

stages:
  - sync
  - build
  - release

# 共用脚本定义
.scripts:
  # SSH 配置脚本
  setup_ssh: &setup_ssh |
    echo "配置 SSH..."
    if [ -n "$SSH_PRIVATE_KEY" ] && [ -f "$SSH_PRIVATE_KEY" ]; then
      cp "$SSH_PRIVATE_KEY" /tmp/id_rsa
    else
      echo "$SSH_PRIVATE_KEY" > /tmp/id_rsa
    fi
    chmod 600 /tmp/id_rsa
    eval "$(ssh-agent -s)"
    ssh-add /tmp/id_rsa
    mkdir -p ~/.ssh
    ssh-keyscan github.com >> ~/.ssh/known_hosts

  # Git 用户配置脚本
  setup_git_user: &setup_git_user |
    echo "配置 Git 用户..."
    git config --global user.name "GitLab CI"
    git config --global user.email "ci@nexis.run"

  # 获取完整 Git 历史脚本
  fetch_full_history: &fetch_full_history |
    echo "检查并获取完整的 git 历史..."
    if [ -f .git/shallow ]; then
      echo "检测到浅克隆，正在获取完整历史..."
      git fetch --unshallow origin || git fetch --depth=1000000 origin
    fi
    git fetch --all --tags

  # 添加 GitHub 远程仓库脚本
  add_github_remote: &add_github_remote |
    echo "配置 GitHub 远程仓库..."
    git remote | grep -q '^github$' && git remote remove github
    git remote add github git@github.com:nexisproject/nexa.git

sync:
  stage: sync
  tags:
    - shell
  only:
    refs:
      - master
  script:
    - |
      set -e  # 遇到错误立即退出
      
      echo "==================== 开始同步代码到 GitHub ===================="
    - *setup_ssh
    - *setup_git_user
    - *fetch_full_history
    - *add_github_remote
    - |
      # 直接推送当前代码到 GitHub master 分支
      echo "推送当前代码到 GitHub master 分支..."
      CURRENT_COMMIT=$(git rev-parse HEAD)
      echo "当前 commit: $CURRENT_COMMIT"
      
      # 使用 HEAD:refs/heads/master 直接推送，无需本地分支操作
      git push --force github HEAD:refs/heads/master
      echo "✓ 已将 commit $CURRENT_COMMIT 推送到 GitHub master 分支"
      
      # 同步所有 tags 到 GitHub
      echo "同步所有 tags 到 GitHub..."
      git push --force github --tags || echo "警告: tags 同步失败或无新 tags"
      
      echo "==================== GitHub 代码同步完成 ===================="

build:
  stage: build
  tags:
    - shell
  rules:
    # 规则 1: master 分支且 cmd/nexa 有变更 - 总是执行
    - if: '$CI_COMMIT_BRANCH == "master"'
      changes:
        - cmd/nexa/**/*
      when: always
    # 规则 2: master 分支，即使无变更也可手动触发
    - if: '$CI_COMMIT_BRANCH == "master"'
      when: manual
      allow_failure: true
  artifacts:
    paths:
      - bin/
    expire_in: 1 hour
  script:
    # 检查上次 pipeline 是否失败
    - |
      echo "检查上次 pipeline 状态..."
      LAST_PIPELINE=$(curl -s --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
        "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/pipelines?ref=master&per_page=2" | \
        grep -o '"status":"[^"]*"' | head -2 | tail -1 | cut -d'"' -f4 || echo "unknown")
      echo "上次 pipeline 状态: $LAST_PIPELINE"
      
      if [ "$LAST_PIPELINE" = "failed" ]; then
        echo "⚠️  检测到上次 pipeline 失败，本次将强制执行构建"
      fi
    - |
      make clean
      echo "从源码 cmd/nexa/main.go 中获取版本号..."
      VERSION=$(grep -E '^\s*Version\s*=' cmd/nexa/main.go | awk -F'"' '{print $2}')
      echo "基础版本号: $VERSION"
      
      if [ -z "$VERSION" ]; then
        echo "错误: 无法从 cmd/nexa/main.go 提取版本号"
        exit 1
      fi
      
      echo "获取 Commit Short Hash..."
      COMMIT_HASH=$(git rev-parse --short HEAD)
      echo "Commit Short Hash: $COMMIT_HASH"
      
      echo "获取构建时间..."
      BUILD_TIME=$(date -u '+%Y-%m-%dT%H:%M:%S+00:00')
      echo "Build Time: $BUILD_TIME"
      
      echo "开始跨平台交叉编译..."
      VERSION=$VERSION HASH=$COMMIT_HASH BUILD_TIME=$BUILD_TIME make all
      
      echo "验证构建产物..."
      ./bin/nexa-$(uname -s | tr '[:upper:]' '[:lower:]')-$(uname -m | sed 's/x86_64/amd64/;s/aarch64/arm64/') --version || true

release:
  stage: release
  tags:
    - shell
  needs: [build]
  rules:
    # 规则 1: master 分支且 cmd/nexa 有变更
    - if: '$CI_COMMIT_BRANCH == "master"'
      changes:
        - cmd/nexa/**/*
      when: always
    # 规则 2: master 分支且 build stage 存在（说明 build 被触发了）
    - if: '$CI_COMMIT_BRANCH == "master" && ($CI_PIPELINE_SOURCE == "push" || $CI_PIPELINE_SOURCE == "web")'
      when: on_success
    # 规则 3: 手动触发
    - if: '$CI_COMMIT_BRANCH == "master"'
      when: manual
      allow_failure: true
  script:
    - |
      set -e  # 遇到错误立即退出
    - *setup_ssh
    - *setup_git_user
    - *fetch_full_history
    - |
      # 获取版本号（格式: 0.1.0.508c2eb）
      echo "获取版本号..."
      VERSION=$(grep -E '^\s*Version\s*=' cmd/nexa/main.go | awk -F'"' '{print $2}')
      
      if [ -z "$VERSION" ]; then
        echo "错误: 无法从 cmd/nexa/main.go 提取版本号"
        exit 1
      fi
      
      COMMIT_HASH=$(git rev-parse --short HEAD)
      FULL_VERSION="${VERSION}.${COMMIT_HASH}"
      TAG="${FULL_VERSION}"
      echo "完整版本号: $FULL_VERSION"
      echo "版本标签: $TAG"

      # 验证 GitHub Token
      echo "验证 GitHub Token..."
      if [ -z "$GITHUB_TOKEN" ]; then
        echo "错误: GITHUB_TOKEN 环境变量未设置!"
        echo "请在 GitLab CI/CD Settings -> Variables 中添加 GITHUB_TOKEN"
        exit 1
      fi
      
      # 测试 Token 有效性
      TOKEN_TEST=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token $GITHUB_TOKEN" https://api.github.com/user)
      if [ "$TOKEN_TEST" != "200" ]; then
        echo "错误: GitHub Token 无效或已过期 (HTTP $TOKEN_TEST)"
        echo "请检查 GITHUB_TOKEN 是否正确配置"
        echo "Token 需要以下权限: repo (完整仓库访问权限)"
        exit 1
      fi
      echo "GitHub Token 验证成功"
    - *add_github_remote
    - |
      # 创建并推送 tag
      echo "创建并推送 tag..."
      git tag -a "$TAG" -m "Release $TAG" || true
      
      # 直接推送 tag，无需推送 master 分支（sync 阶段已处理）
      echo "推送 tag $TAG 到 GitHub..."
      git push github "$TAG" || git push --force github "$TAG"
      echo "✓ tag $TAG 推送成功"

      # 获取提交日志作为 release notes
      echo "生成 Release Notes..."
      LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
      if [ -n "$LAST_TAG" ]; then
        RELEASE_NOTES=$(git log --pretty=format:'- %s' ${LAST_TAG}..HEAD | head -20)
      else
        RELEASE_NOTES=$(git log --pretty=format:'- %s' HEAD~10..HEAD)
      fi
      
      if [ -z "$RELEASE_NOTES" ]; then 
        RELEASE_NOTES="Auto release by GitLab CI for $TAG"
      fi
      
      # 转义 JSON 特殊字符
      RELEASE_NOTES=$(echo "$RELEASE_NOTES" | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g')

      # 发布 GitHub Release 并上传产物
      echo "创建 GitHub Release..."
      API_JSON=$(cat <<EOF
      {
        "tag_name": "$TAG",
        "name": "$TAG",
        "body": "$RELEASE_NOTES",
        "draft": false,
        "prerelease": false
      }
      EOF
      )
      
      RESPONSE=$(curl -s -w "\n%{http_code}" -X POST https://api.github.com/repos/nexisproject/nexa/releases \
        -H "Authorization: token $GITHUB_TOKEN" \
        -H "Content-Type: application/json" \
        -d "$API_JSON")
      
      HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
      RESPONSE_BODY=$(echo "$RESPONSE" | sed '$d')
      
      echo "HTTP 状态码: $HTTP_CODE"
      echo "响应内容: $RESPONSE_BODY"
      
      if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
        echo "创建 Release 失败!"
        exit 1
      fi
      
      UPLOAD_URL=$(echo "$RESPONSE_BODY" | grep -o '"upload_url": "[^"]*' | sed 's/"upload_url": "//' | sed 's/{?name,label}//')
      
      if [ -z "$UPLOAD_URL" ]; then
        echo "无法获取上传 URL!"
        exit 1
      fi
      
      echo "上传 URL: $UPLOAD_URL"
      
      # 上传产物
      for file in bin/*; do
        [ -e "$file" ] || continue
        FILENAME=$(basename "$file")
        echo "上传产物: $FILENAME"
        curl -s -w "\nHTTP: %{http_code}\n" -X POST "$UPLOAD_URL?name=$FILENAME" \
          -H "Authorization: token $GITHUB_TOKEN" \
          -H "Content-Type: application/octet-stream" \
          --data-binary @"$file"
      done
      
      echo "Release 发布完成!"
