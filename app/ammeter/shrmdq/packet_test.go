// Copyright (C) micros. 2024-present.
//
// Created at 2024-12-11, by liasica

package shrmdq

import (
	"encoding/binary"
	"testing"

	"github.com/stretchr/testify/require"

	"orba.plus/nexa/app/ammeter/dlt6452007"
)

func TestPacket_Decode(t *testing.T) {
	var tests = map[string]struct {
		raw  []byte
		want Packet
	}{
		"注册": {
			raw: []byte{0x64, 0x7D, 0x00, 0x00, 0x7D, 0x00, 0x00, 0x00, 0x81, 0x11, 0x00, 0x4D, 0x4C, 0x33, 0x30, 0x37, 0x41, 0x5F, 0x76, 0x32, 0x30, 0x32, 0x33, 0x30, 0x34, 0x32, 0x32, 0x52, 0x0F, 0x00, 0x38, 0x36, 0x34, 0x36, 0x30, 0x36, 0x30, 0x36, 0x30, 0x31, 0x32, 0x36, 0x33, 0x34, 0x38, 0x14, 0x00, 0x38, 0x39, 0x38, 0x36, 0x30, 0x36, 0x32, 0x30, 0x32, 0x33, 0x30, 0x30, 0x33, 0x37, 0x30, 0x37, 0x38, 0x37, 0x34, 0x32, 0x01, 0x00, 0x1F, 0x2A, 0x00, 0xFE, 0xFE, 0xFE, 0xFE, 0x68, 0x77, 0x32, 0x09, 0x19, 0x04, 0x22, 0x68, 0x91, 0x1A, 0x34, 0x37, 0x33, 0x37, 0xAA, 0x65, 0x3C, 0x4C, 0x37, 0x55, 0x65, 0x63, 0x65, 0x65, 0x63, 0x68, 0x63, 0x67, 0x92, 0xA9, 0x9A, 0x6C, 0x6B, 0x64, 0x64, 0x33, 0x32, 0x16, 0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0xC6, 0xEA, 0x20},
			want: Packet{
				Start: 0x64,
				Len:   [2]byte{0x7d, 0x00},
				Keep:  0x00,
				Sn:    [4]byte{0x7d, 0x00, 0x00, 0x00},
				Code:  0x81,
				Data:  []byte{0x11, 0x00, 0x4D, 0x4C, 0x33, 0x30, 0x37, 0x41, 0x5F, 0x76, 0x32, 0x30, 0x32, 0x33, 0x30, 0x34, 0x32, 0x32, 0x52, 0x0F, 0x00, 0x38, 0x36, 0x34, 0x36, 0x30, 0x36, 0x30, 0x36, 0x30, 0x31, 0x32, 0x36, 0x33, 0x34, 0x38, 0x14, 0x00, 0x38, 0x39, 0x38, 0x36, 0x30, 0x36, 0x32, 0x30, 0x32, 0x33, 0x30, 0x30, 0x33, 0x37, 0x30, 0x37, 0x38, 0x37, 0x34, 0x32, 0x01, 0x00, 0x1F, 0x2A, 0x00, 0xFE, 0xFE, 0xFE, 0xFE, 0x68, 0x77, 0x32, 0x09, 0x19, 0x04, 0x22, 0x68, 0x91, 0x1A, 0x34, 0x37, 0x33, 0x37, 0xAA, 0x65, 0x3C, 0x4C, 0x37, 0x55, 0x65, 0x63, 0x65, 0x65, 0x63, 0x68, 0x63, 0x67, 0x92, 0xA9, 0x9A, 0x6C, 0x6B, 0x64, 0x64, 0x33, 0x32, 0x16, 0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00},
				Sum:   [2]byte{0xc6, 0xea},
				End:   0x20,
			},
		},
		"心跳": {
			raw: []byte{0x64, 0x6C, 0x00, 0x00, 0x8F, 0x0C, 0x00, 0x00, 0x83, 0x01, 0x00, 0x1F, 0x01, 0x00, 0x02, 0x40, 0x00, 0xFE, 0xFE, 0xFE, 0xFE, 0x68, 0x72, 0x32, 0x09, 0x19, 0x04, 0x22, 0x68, 0x91, 0x30, 0x35, 0x3F, 0x32, 0x37, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x53, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xDD, 0x33, 0x33, 0x33, 0x33, 0x34, 0x33, 0x33, 0x33, 0x31, 0xE7, 0x16, 0x16, 0x00, 0xFE, 0xFE, 0xFE, 0xFE, 0x68, 0x72, 0x32, 0x09, 0x19, 0x04, 0x22, 0x68, 0x91, 0x06, 0x36, 0x38, 0x33, 0x37, 0x33, 0x33, 0x91, 0x16, 0x24, 0x3A, 0x20},
			want: Packet{
				Start: 0x64,
				Len:   [2]byte{0x6c, 0x0},
				Keep:  0x00,
				Sn:    [4]byte{0x8f, 0x0c, 0x00, 0x00},
				Code:  0x83,
				Data:  []byte{0x01, 0x00, 0x1F, 0x01, 0x00, 0x02, 0x40, 0x00, 0xFE, 0xFE, 0xFE, 0xFE, 0x68, 0x72, 0x32, 0x09, 0x19, 0x04, 0x22, 0x68, 0x91, 0x30, 0x35, 0x3F, 0x32, 0x37, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x53, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xDD, 0x33, 0x33, 0x33, 0x33, 0x34, 0x33, 0x33, 0x33, 0x31, 0xE7, 0x16, 0x16, 0x00, 0xFE, 0xFE, 0xFE, 0xFE, 0x68, 0x72, 0x32, 0x09, 0x19, 0x04, 0x22, 0x68, 0x91, 0x06, 0x36, 0x38, 0x33, 0x37, 0x33, 0x33, 0x91, 0x16},
				Sum:   [2]byte{0x24, 0x3a},
				End:   0x20,
			},
		},
		"查询信号强度返回": {
			raw: []byte{0x64, 0x0F, 0x00, 0x01, 0x4E, 0x00, 0x00, 0x00, 0x87, 0x01, 0x00, 0x1F, 0xD5, 0xDC, 0x20},
			want: Packet{
				Start: 0x64,
				Len:   [2]byte{0x0f, 0x00},
				Keep:  0x01,
				Sn:    [4]byte{0x4e, 0x00, 0x00, 0x00},
				Code:  0x87,
				Data:  []byte{0x01, 0x00, 0x1f},
				Sum:   [2]byte{0xd5, 0xdc},
				End:   0x20,
			},
		},
		"透传指令返回": {
			raw: []byte{0x64, 0x29, 0x00, 0x01, 0x33, 0x00, 0x00, 0x00, 0x8A, 0x01, 0x00, 0x01, 0x18, 0x00, 0xFE, 0xFE, 0xFE, 0xFE, 0x68, 0x72, 0x32, 0x09, 0x19, 0x04, 0x22, 0x68, 0x91, 0x08, 0x33, 0x33, 0x34, 0x33, 0x33, 0x33, 0x33, 0x33, 0xEE, 0x16, 0x32, 0xE2, 0x20},
			want: Packet{
				Start: 0x64,
				Len:   [2]byte{0x29, 0x00},
				Keep:  0x01,
				Sn:    [4]byte{0x33, 0x00, 0x00, 0x00},
				Code:  0x8a,
				Data:  []byte{0x01, 0x00, 0x01, 0x18, 0x00, 0xFE, 0xFE, 0xFE, 0xFE, 0x68, 0x72, 0x32, 0x09, 0x19, 0x04, 0x22, 0x68, 0x91, 0x08, 0x33, 0x33, 0x34, 0x33, 0x33, 0x33, 0x33, 0x33, 0xEE, 0x16},
				Sum:   [2]byte{0x32, 0xE2},
				End:   0x20,
			},
		},
	}

	for name, tt := range tests {
		t.Run(name, func(t *testing.T) {
			p, err := NewPacket().Decode(tt.raw)
			require.NoError(t, err)
			require.True(t, tt.want.Compare(p))
		})
	}
}

func TestRegister(t *testing.T) {
	b := []byte{0x64, 0x81, 0x0, 0x0, 0xb8, 0x3, 0x0, 0x0, 0x81, 0x15, 0x0, 0x4d, 0x4c, 0x33, 0x30, 0x37, 0x41, 0x5f, 0x31, 0x34, 0x32, 0x5f, 0x76, 0x32, 0x30, 0x32, 0x34, 0x31, 0x31, 0x32, 0x31, 0x52, 0xf, 0x0, 0x38, 0x36, 0x30, 0x32, 0x38, 0x39, 0x30, 0x37, 0x33, 0x32, 0x38, 0x36, 0x36, 0x35, 0x38, 0x14, 0x0, 0x38, 0x39, 0x38, 0x36, 0x30, 0x38, 0x34, 0x30, 0x31, 0x32, 0x32, 0x34, 0x39, 0x30, 0x31, 0x30, 0x35, 0x37, 0x38, 0x32, 0x1, 0x0, 0x10, 0x2a, 0x0, 0xfe, 0xfe, 0xfe, 0xfe, 0x68, 0x34, 0x18, 0x4, 0x24, 0x6, 0x24, 0x68, 0x91, 0x1a, 0x34, 0x37, 0x33, 0x37, 0x67, 0x4b, 0x37, 0x57, 0x39, 0x57, 0x65, 0x63, 0x65, 0x65, 0x63, 0x6c, 0x63, 0x65, 0x92, 0xa9, 0x9a, 0x6c, 0x6b, 0x64, 0x64, 0x33, 0x8e, 0x16, 0x0, 0x0, 0x4, 0x0, 0x1, 0x0, 0x0, 0x0, 0x21, 0xd2, 0x20}
	p, err := NewPacket().Decode(b)
	require.NoError(t, err)
	t.Logf("%#v", p)

	var msg Message
	msg, err = p.GetMessage()
	require.NoError(t, err)
	t.Logf("%#v", msg)
}

func TestHeartBeat(t *testing.T) {
	// b := []byte{0x64, 0x7a, 0x0, 0x0, 0xb4, 0x44, 0x0, 0x0, 0x83, 0x1, 0x0, 0x11, 0x1, 0x0, 0x2, 0x40, 0x0, 0xfe, 0xfe, 0xfe, 0xfe, 0x68, 0x34, 0x18, 0x4, 0x24, 0x6, 0x24, 0x68, 0x91, 0x30, 0x35, 0x3f, 0x32, 0x37, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x35, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3d, 0x33, 0x33, 0x33, 0x33, 0x33, 0xdd, 0x33, 0x33, 0x33, 0x5d, 0x72, 0x33, 0x33, 0x33, 0x85, 0x41, 0x16, 0x24, 0x0, 0xfe, 0xfe, 0xfe, 0xfe, 0x68, 0x34, 0x18, 0x4, 0x24, 0x6, 0x24, 0x68, 0x91, 0x14, 0x32, 0x38, 0x33, 0x37, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xb, 0x33, 0xef, 0x16, 0x1d, 0xc7, 0x20}
	b := []byte{0x64, 0x7a, 0x0, 0x0, 0x5b, 0x1a, 0x0, 0x0, 0x83, 0x1, 0x0, 0x11, 0x1, 0x0, 0x2, 0x40, 0x0, 0xfe, 0xfe, 0xfe, 0xfe, 0x68, 0x34, 0x18, 0x4, 0x24, 0x6, 0x24, 0x68, 0x91, 0x30, 0x35, 0x3f, 0x32, 0x37, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x34, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x39, 0x33, 0x33, 0x33, 0x33, 0x33, 0xdd, 0x33, 0x33, 0x33, 0x5d, 0x72, 0x33, 0x33, 0x33, 0x80, 0x37, 0x16, 0x24, 0x0, 0xfe, 0xfe, 0xfe, 0xfe, 0x68, 0x34, 0x18, 0x4, 0x24, 0x6, 0x24, 0x68, 0x91, 0x14, 0x32, 0x38, 0x33, 0x37, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xb, 0x33, 0xef, 0x16, 0x3a, 0x24, 0x20}
	p, err := NewPacket().Decode(b)
	require.NoError(t, err)
	t.Logf("%#v", p)

	var msg Message
	msg, err = p.GetMessage()
	require.NoError(t, err)
	t.Logf("%#v", msg)
}

func TestBuild(t *testing.T) {
	b := NewPacket().SetKeep(CommandDefaultKeep).SetCode(CodeSignalD).SetSn([]byte{0x4e, 0x00, 0x00, 0x00}).Build()
	want := []byte{0x64, 0x0C, 0x00, 0x01, 0x4E, 0x00, 0x00, 0x00, 0x07, 0xB8, 0x7A, 0x20}
	require.Equal(t, b, want)
}

func TestPassthrough(t *testing.T) {
	b := []byte{0x64, 0x29, 0x0, 0x1, 0x3b, 0x2a, 0x9c, 0x62, 0x8a, 0x1, 0x0, 0x1, 0x18, 0x0, 0xfe, 0xfe, 0xfe, 0xfe, 0x68, 0x34, 0x18, 0x4, 0x24, 0x6, 0x24, 0x68, 0x91, 0x8, 0x33, 0x33, 0x33, 0x33, 0x44, 0x33, 0x33, 0x33, 0xb0, 0x16, 0x69, 0x20, 0x20}
	p, err := NewPacket().Decode(b)
	require.NoError(t, err)
	t.Logf("%#v", p)

	var msg Message
	msg, err = p.GetMessage()
	require.NoError(t, err)
	t.Logf("%#v", msg)
}

func TestCommand(t *testing.T) {
	b := dlt6452007.New("220419093272", dlt6452007.IForwardPowerTotal, nil).Bytes()

	// 拼接数据
	l := make([]byte, 2)
	binary.LittleEndian.PutUint16(l, 1)

	data := NewMontage(nil).
		AddDecomposed(l).
		AddDecomposed(b).
		Compose().
		GetComposed()

	t.Logf("%#v", data)

	// []byte{0x14, 0x0, 0xfe, 0xfe, 0xfe, 0xfe, 0x68, 0x72, 0x32, 0x9, 0x19, 0x4, 0x22, 0x68, 0x11, 0x4, 0x33, 0x33, 0x34, 0x33, 0x9e, 0x16}
	// []byte{0x14, 0x0, 0xFE, 0xFE, 0xFE, 0xFE, 0x68, 0x72, 0x32, 0x9, 0x19, 0x4, 0x22, 0x68, 0x11, 0x4, 0x33, 0x33, 0x34, 0x33, 0x9E, 0x16}
	cmd := NewPacket().SetCode(CodePassthroughD).SetSn().SetKeep(CommandDefaultKeep).SetData(data).Build()
	t.Logf("%X", cmd)

	x := make([]byte, 2)
	binary.LittleEndian.PutUint16(x, 2)
	t.Logf("%#v", x)
}
